# LeetCode-91-Decode Ways-解码方法

## 题目要求：
![avatar](https://github.com/JakeChanFangZiyuan20/MyLeetCode/blob/master/img/91.png)

## 综述：  
\+ 该题使用动态规划方法。  
\+ dp[0] = 0 ，dp[1] = 1，dp[i] 为第 1 个 到 i 个字符所能组合的总数，如果 s[i] 和 s[i - 1] 组合转换为整数在 1 到 26 内（包含 1 和 26），则 dp[i] = dp[i - 1] + dp[i - 2]，否则 dp[i] = dp[i - 1] 。  
\+ 说明：当前字符的加入回对已有字符串产生影响：  
\+ 如果当前字符加入和已有字符串的最后一个字符组合后转换为整数不在 1 到 26 内（包含 1 和 26）内，说明当前字符的加入对已有字符串不会有任何影响，所以所能组成的解码数仍然为已有字符串的所能组成的解码数。  
\+ 若当前字符加入和已有字符串的最后一个字符组合后转换为整数在 1 到 26 内（包含 1 和 26）内，说明这里有两种情况，就是当前字符串不加入，解码总数仍未已有字符串，如果选择加入，加入后可看成当前字符和已有字符串的最后一个字符为一个字符，然后此时解码总数为已有字符串的前 n - 1 个字符组成的字符串的解码总数。所以在该情况下，解码总数为两部分的和。  
\+ **特殊情况**：'0' 的存在。'0' 字符的前一个字符只有为 '1' 或 '2' 的时候才可以找到对应字母，所以如果 '0' 字符的前一个字符不为 '1' 或 '2' 时，最终结果只能为 0。但如果 '0' 字符（此时下标为 i ）的前一个字符为 '1' 或 '2' 时，dp[i] = dp[i - 1] = dp[i - 2]，因为  '0' 字符必须和 '1' 或 '2' 捆绑，这会导致 '0' 字符前面的字符串少去最后一字符。  

## Code
```
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        if(n == 0 || s[0] == '0') return 0;

        string cur;
        int a = 1, b = 1, c = b, curInt;
        for(int i = 1; i < n; i++){
            if(s[i] == '0'){
                if(s[i - 1] != '2' && s[i - 1] != '1') return 0;
                else{
                    b = a;
                    continue;
                }
            }
            if(s[i - 1] == '0') continue;
            cur = string({s[i - 1], s[i]});
            curInt = stoi(cur);
            if(s[i - 1] != '0' && 1 <= curInt && curInt <= 26) c = a + b;
            else c = b;
            a = b;
            b = c;
        }
        return b;
    }
};
```


## 复杂度分析
空间复杂度O(1)  
时间复杂度O(n)

